{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"build-a-thread-network-with-nrf52840-mdk/","title":"Build a Thread network with nRF52840-MDK","text":""},{"location":"build-a-thread-network-with-nrf52840-mdk/#build-a-thread-network-with-nrf52840-mdk","title":"Build a Thread network with nRF52840-MDK","text":""},{"location":"build-a-thread-network-with-nrf52840-mdk/#introduction","title":"Introduction","text":"<p>OpenThread is an open-source implementation of the Thread\u00ae networking protocol. Nest has released OpenThread to make the networking technology used in Nest products more broadly available to developers, in order to accelerate the development of products for the connected home.</p> <p>The Thread specification defines an IPv6-based reliable, secure and low-power wireless device-to-device communication protocol for home applications. OpenThread implements all Thread networking layers (IPv6, 6LoWPAN, IEEE 802.15.4 with MAC security, Mesh Link Establishment, Mesh Routing) and device roles, as well as Border Router support.</p> <p></p>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#whatll-you-need","title":"What'll you need","text":"<ul> <li>3x nRF52840-MDK boards</li> <li>3x USB-C cables</li> <li>A Linux/macOS machine with at least 3 USB ports</li> </ul>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#set-up-your-development-environment","title":"Set up your development environment","text":"<p>The following section provides detailed information about the required software toolchains. Skip any step where a compatible tool already exists.</p> <ol> <li> <p>Download and install the ARM GNU Toolchain. The <code>6-2017-q2-update</code> version is recommended. Then ensure the path is added to your OS PATH environment variable.</p> <pre><code># in ~/.bash_profile, add the following script\nexport PATH=\"&lt;path to install directory&gt;/gcc-arm-none-eabi-6-2017-q2-update/bin:${PATH}\"\n</code></pre> </li> <li> <p>Type the following in your terminal to verify if the path is set correctly:</p> <pre><code>arm-none-eabi-gcc --version\n</code></pre> </li> <li> <p>Install pyOCD:</p> <pre><code>pip install -U pyocd\n</code></pre> </li> <li> <p>Follow the wpantund Installation Guide to install wpantund.</p> </li> <li> <p>Clone and install OpenThread:</p> <pre><code>git clone --recursive https://github.com/makerdiary/openthread.git\ncd openthread\n./bootstrap\n</code></pre> </li> </ol>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#set-up-the-ncp-joiner","title":"Set up the NCP Joiner","text":""},{"location":"build-a-thread-network-with-nrf52840-mdk/#build-and-flash","title":"Build and flash","text":"<p>Build the OpenThread nRF52840 example with Joiner functionality. A device uses the Joiner role to be securely authenticated and commissioned onto a Thread network. Always clean the repo of previous builds first by running <code>make clean</code>.</p> <pre><code>cd ~/openthread\nmake -f examples/Makefile-nrf52840 clean\nmake -f examples/Makefile-nrf52840 JOINER=1\n</code></pre> <p>Navigate to the directory with the OpenThread FTD NCP binary, and convert it to hex format:</p> <pre><code>cd ~/openthread/output/nrf52840/bin\narm-none-eabi-objcopy -O ihex ot-ncp-ftd ot-ncp-ftd.hex\n</code></pre> <p>Connect nRF52840-MDK to your computer with a USB cable. Flash the OpenThread NCP FTD hex file onto the nRF52840-MDK and label the board NCP so that later you don't confuse the board roles.</p> <pre><code>pyocd flash -t nrf52840 ot-ncp-ftd.hex\n</code></pre>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#configure-wpantund","title":"Configure wpantund","text":"<p>In the NCP design, use wpantund to communicate with and manage the Thread device.</p> <p>In a terminal window, start <code>wpantund</code> on the serial port with the NCP, creating the interface <code>utun7</code> and enabling info logs:</p> <pre><code>sudo /usr/local/sbin/wpantund -o Config:NCP:SocketPath /dev/cu.usbmodem14112  \\\n        -o Config:TUN:InterfaceName utun7 \\\n        -o Daemon:SyslogMask \" -info\"\n</code></pre> <p>Output similar to the following is generated upon success:</p> <pre><code>Jun  9 01:29:49  wpantund[12257] &lt;Notice&gt;: Starting wpantund 0.08.00d (Jun  9 2018 00:31:51) . . .\nJun  9 01:29:49  wpantund[12257] &lt;Notice&gt;:  SOURCE_VERSION = 0.07.01-217-g86d29d6\nJun  9 01:29:49  wpantund[12257] &lt;Notice&gt;:  BUILD_VERSION = 0.07.01-217-g86d29d6\nJun  9 01:29:49  wpantund[12257] &lt;Notice&gt;: Configuration file \"/etc/wpantund.conf\" read.\nJun  9 01:29:49  wpantund[12257] &lt;Notice&gt;: Ready. Using DBUS bus \":1.2\"\nJun  9 01:29:49  wpantund[12257] &lt;Notice&gt;: Running as root without dropping privileges!\nJun  9 01:29:49  wpantund[12257] &lt;Notice&gt;: State change: \"uninitialized\" -&gt; \"offline\"\nJun  9 01:29:49  wpantund[12257] &lt;Notice&gt;: NCP is running \"OPENTHREAD/20170716-00584-ge4f5f240-dirty; NRF52840; Jun  8 2018 23:36:19\"\nJun  9 01:29:49  wpantund[12257] &lt;Notice&gt;: Driver is running \"0.08.00d (0.07.01-217-g86d29d6; Jun  9 2018 00:31:51)\"\n1:29:49  wpantund[12257] &lt;Notice&gt;: Network is not joinable\nJun  9 01:29:49  wpantund[12257] &lt;Notice&gt;: Resetting interface(s). . .\nJun  9 01:29:49  wpantund[12257] &lt;Notice&gt;: Finished initializing NCP\n</code></pre> <p>Leave this terminal window open so that logs from wpantund can be viewed.</p> <p>A user-defined interface is required to communicate with the NCP using <code>wpanctl</code>. Open a new terminal window and using <code>wpanctl</code>, connect to the interface you just set up:</p> <pre><code>sudo /usr/local/bin/wpanctl -I utun7\nwpanctl:utun7&gt;\nwpanctl:utun7&gt; status\n</code></pre> <p></p>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#set-up-the-ftds","title":"Set up the FTDs","text":"<p>The other two Thread nodes used in this section are Full Thread Devices (FTDs) on the standard System-on-Chip (SoC) design. They do not use <code>wpantund</code>, and the user manually manages them with the OpenThread CLI.</p> <p>One device functions as the Commissioner, to securely authenticate and commission devices onto that network. The other device functions as a Joiner that the Commissioner can authenticate to the Thread network.</p>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#build-and-flash_1","title":"Build and flash","text":"<p>Build the OpenThread FTD example for the nRF52840-MDK, with the Commissioner and Joiner roles enabled:</p> <pre><code>cd ~/openthread\nmake -f examples/Makefile-nrf52840 clean\nmake -f examples/Makefile-nrf52840 COMMISSIONER=1 JOINER=1\n</code></pre> <p>Navigate to the directory with the OpenThread Full Thread Device (FTD) CLI binary, and convert it to hex format:</p> <pre><code>cd ~/openthread/output/nrf52840/bin\narm-none-eabi-objcopy -O ihex ot-cli-ftd ot-cli-ftd.hex\n</code></pre> <p>Connect another nRF52840-MDK to your computer with a USB cable. Flash the OpenThread CLI FTD hex file and label the board Commissioner:</p> <pre><code>pyocd flash -t nrf52840 ot-cli-ftd.hex\n</code></pre>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#verify-build","title":"Verify build","text":"<p>Verify a successful build by accessing the OpenThread CLI using a terminal application. The nRF52840-MDK boards use a baud rate of <code>115200</code>.</p> <pre><code># For example, using screen\nscreen /dev/cu.usbmodem142112 115200\n</code></pre> <p>In the terminal window, press Enter on the keyboard a few times to bring up the OpenThread CLI <code>&gt;</code> prompt. Check for IPv6 addresses:</p> <pre><code>&gt; ipaddr\nfd11:2233:4455:0:99ea:1fe9:acd6:d384\nfe80:0:0:0:2003:a240:810f:1598\nDone\n</code></pre>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#set-up-the-ftd-joiner","title":"Set up the FTD Joiner","text":"<p>Repeat the above process to flash the third nRF52840-MDK board, using the existing <code>ot-cli-ftd.hex</code> build. Then label the board Joiner. Check for IPv6 addresses in the terminal window:</p> <pre><code>&gt; ipaddr\nfe80:0:0:0:d079:7d86:6413:4f4e\nfd11:2233:4455:0:e839:eb52:f7ec:74e3\nDone\n</code></pre>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#create-the-thread-network","title":"Create the Thread network","text":"<p>Now that you have all your terminal windows and screens configured, let's create our Thread network. On the Commissioner, configure the network and bring up Thread:</p> <pre><code>## FTD Commissioner ##\n----------------------\n\n&gt; networkname makerdiary\nDone\n&gt; extpanid 1122334455667788\nDone\n&gt; panid 0x1122\nDone\n&gt; masterkey 11223344556677881122334455667788\nDone\n&gt; ifconfig up\nDone\n&gt; thread start\nDone\n</code></pre> <p>After a moment, check the device state. It should be the Leader. Also get the <code>RLOC16</code> for future reference.</p> <pre><code>## FTD Commissioner ##\n----------------------\n\n&gt; state\nleader\nDone\n&gt; rloc16\n3400\nDone\n</code></pre> <p>Check the device's IPv6 addresses:</p> <pre><code>## FTD Commissioner ##\n----------------------\n\n&gt; ipaddr\nfd11:2233:4455:0:0:ff:fe00:fc00        # Leader Anycast Locator (ALOC)\nfd11:2233:4455:0:0:ff:fe00:3400        # Routing Locator (RLOC)\nfd11:2233:4455:0:99ea:1fe9:acd6:d384   # Mesh-Local EID (ML-EID)\nfe80:0:0:0:2003:a240:810f:1598         # Link-Local Address (LLA)\nDone\n</code></pre> <p>The <code>makerdiary</code> network is now visible when scanned from other Thread devices.</p> <p>From <code>wpanctl</code> on the NCP Joiner:</p> <pre><code>## NCP Joiner ##\n----------------\n\nwpanctl:utun7&gt; scan\n   | Joinable | NetworkName        | PAN ID | Ch | XPanID           | HWAddr           | RSSI\n---+----------+--------------------+--------+----+------------------+------------------+------\n 1 |       NO | \"makerdiary\"       | 0x1122 | 11 | 1122334455667788 | 2203A240810F1598 |  -59\n</code></pre> <p>From the OpenThread CLI on the FTD Joiner:</p> <pre><code>## FTD Joiner ##\n----------------\n\n&gt; scan\n| J | Network Name     | Extended PAN     | PAN  | MAC Address      | Ch | dBm | LQI |\n+---+------------------+------------------+------+------------------+----+-----+-----+\n&gt; | 0 | makerdiary       | 1122334455667788 | 1122 | 2203a240810f1598 | 11 | -32 | 244 |\nDone\n</code></pre> <p>If the <code>makerdiary</code> network doesn't appear in the list, try scanning again.</p> <p>You may note that in both scans, the network seems to be not joinable (Joinable column on the NCP Joiner, J column on the FTD Joiner). This only means that Thread Commissioning is not active on the network. It can still be joined out-of-band, by entering the network master key in the joiner device manually.</p>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#add-the-ncp-joiner","title":"Add the NCP Joiner","text":"<p>Let's add the NCP Joiner to the Thread network we just created, using an out-of-band process. Scan for networks on the NCP Joiner:</p> <pre><code>## NCP Joiner ##\n----------------\n\nwpanctl:utun7&gt; scan\n   | Joinable | NetworkName        | PAN ID | Ch | XPanID           | HWAddr           | RSSI\n---+----------+--------------------+--------+----+------------------+------------------+------\n 1 |       NO | \"makerdiary\"       | 0x1122 | 11 | 1122334455667788 | EE7A6D71FB28C60D |  -68\n</code></pre> <p>To join, set the network master key on the NCP Joiner and join network <code>1</code> (the ID in the first column of the scan output):</p> <pre><code>## NCP Joiner ##\n----------------\n\nwpanctl:utun7&gt; setprop Network:Key 11223344556677881122334455667788\nwpanctl:utun7&gt; join 1\nJoining \"makerdiary\" 1122334455667788 as node type \"end-device\"\nSuccessfully Joined!\n</code></pre> <p>Check the status of the NCP Joiner to verify. It might take a few seconds for all IPv6 addresses to appear in the output.</p> <pre><code>## NCP Joiner ##\n----------------\n\nwpanctl:utun7&gt; status\nutun7 =&gt; [\n    \"NCP:State\" =&gt; \"associated\"\n    \"Daemon:Enabled\" =&gt; true\n    \"NCP:Version\" =&gt; \"OPENTHREAD/20170716-00650-g631557e8-dirty; NRF52840; Jun  9 2018 15:45:03\"\n    \"Daemon:Version\" =&gt; \"0.08.00d (0.07.01-217-g86d29d6; Jun  9 2018 00:31:51)\"\n    \"Config:NCP:DriverName\" =&gt; \"spinel\"\n    \"NCP:HardwareAddress\" =&gt; [9019EC5D617D7AAB]\n    \"NCP:Channel\" =&gt; 11\n    \"Network:NodeType\" =&gt; \"end-device\"\n    \"Network:Name\" =&gt; \"makerdiary\"\n    \"Network:XPANID\" =&gt; 0x1122334455667788\n    \"Network:PANID\" =&gt; 0x1122\n    \"IPv6:LinkLocalAddress\" =&gt; \"fe80::60bd:ff84:2121:344d\"\n    \"IPv6:MeshLocalAddress\" =&gt; \"fd11:2233:4455::f:b5e:169b:b875\"\n    \"IPv6:MeshLocalPrefix\" =&gt; \"fd11:2233:4455::/64\"\n    \"com.nestlabs.internal:Network:AllowingJoin\" =&gt; false\n]\n</code></pre> <p>Make note of the <code>IPv6:MeshLocalAddress</code>, you'll use it later.</p> <p>Get the NCP Joiner's <code>RLOC16</code>:</p> <pre><code>## NCP Joiner ##\n----------------\n\nwpanctl:utun7&gt; getprop Thread:RLOC16\nThread:RLOC16 = 0x3403\n</code></pre> <p>Back on the FTD Commissioner, check the router and child tables to confirm both devices are part of the same network. Use the <code>RLOC16</code> to identify the NCP Joiner.</p> <pre><code>## FTD Commissioner ##\n----------------------\n\n&gt; router table\n| ID | RLOC16 | Next Hop | Path Cost | LQ In | LQ Out | Age | Extended MAC     |\n+----+--------+----------+-----------+-------+--------+-----+------------------+\n| 13 | 0x3400 |       63 |         0 |     0 |      0 |   0 | 2203a240810f1598 |\n\nDone\n&gt; child table\n| ID  | RLOC16 | Timeout    | Age        | LQ In | C_VN |R|S|D|N| Extended MAC     |\n+-----+--------+------------+------------+-------+------+-+-+-+-+------------------+\n|   3 | 0x3403 |        240 |         66 |     3 |   86 |1|1|1|1| 62bdff842121344d |\n\nDone\n</code></pre> <p>Ping the mesh-local address of the NCP Joiner (the <code>IPv6:MeshLocalAddress</code> attribute from the NCP Joiner's <code>status</code> output) to verify connectivity:</p> <pre><code>## FTD Commissioner ##\n----------------------\n\n&gt; ping fd11:2233:4455::f:b5e:169b:b875\n&gt; 8 bytes from fd11:2233:4455:0:f:b5e:169b:b875: icmp_seq=2 hlim=64 time=35ms\n</code></pre> <p></p>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#commission-the-ftd-joiner","title":"Commission the FTD Joiner","text":"<p>Now let's add the third Thread device to the <code>makerdiary</code> network. This time we're going to use the more secure in-band commissioning process. On the FTD Joiner, scan for the network:</p> <pre><code>## FTD Joiner ##\n----------------\n\n&gt; scan\n| J | Network Name     | Extended PAN     | PAN  | MAC Address      | Ch | dBm | LQI |\n+---+------------------+------------------+------+------------------+----+-----+-----+\n&gt; | 0 | makerdiary       | 1122334455667788 | 1122 | 2203a240810f1598 | 11 | -32 | 244 |\nDone\n</code></pre> <p>A <code>0</code> in the <code>J</code> column indicates that Thread Commissioning is not active on the device.</p> <p>Let's be specific when commissioning on this next device, and only allow the FTD Joiner to join. Still on the FTD Joiner, get the <code>eui64</code>, so the FTD Commissioner can identify it:</p> <pre><code>## FTD Joiner ##\n----------------\n\n&gt; eui64\n31ae3e8e7b87cfd6\nDone\n</code></pre> <p>On the FTD Commissioner, start the commissioner and specify the eui64 of the device that can join, along with the Joiner Credential. The Joiner Credential is a device-specific passphrase.</p> <pre><code>## FTD Commissioner ##\n----------------------\n\n&gt; commissioner start\nDone\n&gt; commissioner joiner add 31ae3e8e7b87cfd6 J01NME\nDone\n</code></pre> <p>Switch to the FTD Joiner, and rescan:</p> <pre><code>## FTD Joiner ##\n----------------\n\n&gt; scan\n| J | Network Name     | Extended PAN     | PAN  | MAC Address      | Ch | dBm | LQI |\n+---+------------------+------------------+------+------------------+----+-----+-----+\n&gt; | 1 | makerdiary       | 1122334455667788 | 1122 | 2203a240810f1598 | 11 | -32 | 244 |\nDone\n</code></pre> <p>As indicated by the <code>1</code> in the <code>J</code> column, Thread Commissioning is now active on the network. Start the joiner role with the Joiner Credential you just set up on the FTD Commissioner:</p> <pre><code>## FTD Joiner ##\n----------------\n\n&gt; ifconfig up\nDone\n&gt; joiner start J01NME\nDone\n</code></pre> <p>Within a minute or so, you get a confirmation of a successful authentication.</p> <p>Bring up Thread so the FTD Joiner joins the <code>makerdiary</code> network, and immediately check the state and <code>RLOC16</code>:</p> <pre><code>## FTD Joiner ##\n----------------\n\n&gt; thread start\nDone\n&gt; state\nchild\nDone\n&gt; rloc16\n3404\nDone\n</code></pre> <p>Check the device's IPv6 addresses. Notice that there is no ALOC. That's because this device is not the Leader, nor does it hold an Anycast-specific role that requires an ALOC.</p> <pre><code>## FTD Joiner ##\n----------------\n\n&gt; ipaddr\nfd11:2233:4455:0:0:ff:fe00:3404\nfe80:0:0:0:7827:55cf:47e4:5907\nfd11:2233:4455:0:e839:eb52:f7ec:74e3\nDone\n</code></pre> <p>Immediately switch to the FTD Commissioner and check the router and child tables to confirm that three devices exist in the <code>makerdiary</code> network:</p> <pre><code>## FTD Commissioner ##\n----------------------\n\n&gt; router table\n| ID | RLOC16 | Next Hop | Path Cost | LQ In | LQ Out | Age | Extended MAC     |\n+----+--------+----------+-----------+-------+--------+-----+------------------+\n| 13 | 0x3400 |       63 |         0 |     0 |      0 |   0 | 2203a240810f1598 |\n\nDone\n&gt; child table\n| ID  | RLOC16 | Timeout    | Age        | LQ In | C_VN |R|S|D|N| Extended MAC     |\n+-----+--------+------------+------------+-------+------+-+-+-+-+------------------+\n|   3 | 0x3403 |        240 |        231 |     3 |   86 |1|1|1|1| 62bdff842121344d |\n|   4 | 0x3404 |        240 |         49 |     3 |   88 |1|1|1|1| 7a2755cf47e45907 |\n\nDone\n</code></pre> <p>Based on the <code>RLOC16</code>, the FTD Joiner has attached to the network as an End Device (child). Here is our updated topology:</p> <p></p>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#send-messages-with-udp","title":"Send messages with UDP","text":"<p>One of the application services that OpenThread provides is User Datagram Protocol (UDP), a Transport Layer protocol. An application built on OpenThread could use the UDP API to pass messages between nodes in a Thread network, or to other devices in an external network (like the internet, if the Thread network features a Border Router).</p> <p>UDP sockets are exposed through the OpenThread CLI. Let's use it to pass messages between the two FTDs.</p> <p>Get the Mesh-Local EID address for the FTD Joiner. We're using this address because it's reachable from anywhere within the Thread network.</p> <pre><code>## FTD Joiner ##\n----------------\n\n&gt; ipaddr\nfd11:2233:4455:0:0:ff:fe00:fc00        # Leader Anycast Locator (ALOC)\nfd11:2233:4455:0:0:ff:fe00:f400        # Routing Locator (RLOC)\nfe80:0:0:0:7827:55cf:47e4:5907         # Link-Local Address (LLA)\nfd11:2233:4455:0:e839:eb52:f7ec:74e3   # Mesh-Local EID (ML-EID)\nDone\n</code></pre> <p>Start UDP and bind it to a socket for any IPv6 address:</p> <pre><code>## FTD Joiner ##\n----------------\n\n&gt; udp open\nDone\n&gt; udp bind :: 1212\n</code></pre> <p>Switch to the FTD Commissioner, start UDP, and connect to the socket you set up on the FTD Joiner, using its ML-EID:</p> <pre><code>## FTD Commissioner ##\n----------------------\n\n&gt; udp open\nDone\n&gt; udp connect fd11:2233:4455:0:e839:eb52:f7ec:74e3 1212\nDone\n</code></pre> <p>The UDP connection should be live between the two nodes. Send a message from the FTD Commissioner:</p> <p><pre><code>## FTD Commissioner ##\n----------------------\n\n&gt; udp send hello-openthread\nDone\n</code></pre> On the FTD Joiner, the UDP message has been received!</p> <pre><code>## FTD Joiner ##\n----------------\n\n&gt; 16 bytes from fd11:2233:4455:0:0:ff:fe00:3400 49153 hello-openthread\n</code></pre>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#congratulations","title":"Congratulations!","text":"<p>You've created a physical Thread network with nRF52840-MDK!</p>"},{"location":"build-a-thread-network-with-nrf52840-mdk/#reference","title":"Reference","text":"<ul> <li>Build a Thread network with nRF52840 boards and OpenThread - covers all the steps in this post</li> <li>openthread.io</li> <li>github.com/openthread</li> <li>Thread Primer \u2014 covers all the Thread concepts in this post</li> <li>OpenThread CLI reference</li> <li>OpenThread UDP CLI reference</li> </ul>"},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/","title":"Debugging nRF52840-MDK board with Visual Studio Code","text":""},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/#debugging-nrf52840-mdk-board-with-visual-studio-code","title":"Debugging nRF52840-MDK board with Visual Studio Code","text":""},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/#introduction","title":"Introduction","text":"<p>Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. With the addition of the C/C++ extension to Visual Studio Code, you might have what is needed in such a small, cross-platform editor.</p> <p>This post explains how to configure the local debug toolchain for debugging nRF52840-MDK board with Visual Studio Code.</p>"},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>nRF52840-MDK board</li> <li>1x USB-C cable</li> <li>A Windows/macOS/Linux PC</li> </ul>"},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/#install-visual-studio-code","title":"Install Visual Studio Code","text":"<p>You need to install Visual Studio Code with the C/C++ extensions to begin.</p> <ol> <li>Install Visual Studio Code.</li> <li>Open Visual Studio Code, and click on the Extensions button.</li> <li>Search for the C/C++ plugin (by Microsoft) and click Install.</li> <li>When prompted, restart the IDE.</li> </ol> <p></p>"},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/#install-pyocd","title":"Install pyOCD","text":"<p>The latest stable version of pyOCD may be installed via pip as follows. Skip this step if pyOCD already exists.</p> <pre><code>pip install -U pyocd\n</code></pre>"},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/#install-gnu-arm-embedded-toolchain","title":"Install GNU Arm Embedded Toolchain","text":"<p>Download and install the GNU ARM Embedded Toolchain. Then ensure the path is added to your OS PATH environment variable:</p> <pre><code># in ~/.bash_profile, add the following script\nexport PATH=\"&lt;path to install directory&gt;/gcc-arm-none-eabi-6-2017-q2-update/bin:${PATH}\"\n</code></pre> <p>Type the following in your terminal to verify if arm-none-eabi-gcc works:</p> <pre><code>arm-none-eabi-gcc --version\n</code></pre>"},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/#configuring-the-debugger","title":"Configuring the debugger","text":"<p>The <code>launch.json</code> file is used to configure the debugger in Visual Studio Code. To configure the debugger for your project:</p> <ol> <li> <p>Open the project folder in Visual Studio Code.</p> </li> <li> <p>Open the <code>.vscode/launch.json</code> file and add the example configurations:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"C++ Launch\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceRoot}/armgcc/_build/nrf52840_xxaa.out\",\n            \"args\": [],\n            \"stopAtEntry\": true,\n            \"cwd\": \"${workspaceRoot}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"debugServerArgs\": \"\",\n            \"serverLaunchTimeout\": 20000,\n            \"filterStderr\": true,\n            \"filterStdout\": false,\n            \"serverStarted\": \"GDB\\\\ server\\\\ started\",\n            \"preLaunchTask\": \"make\",\n            \"setupCommands\": [\n                { \"text\": \"-target-select remote localhost:3333\", \"description\": \"connect to target\", \"ignoreFailures\": false },\n                { \"text\": \"-file-exec-and-symbols ${workspaceRoot}/armgcc/_build/nrf52840_xxaa.out\", \"description\": \"load file\", \"ignoreFailures\": false},\n                { \"text\": \"-interpreter-exec console \\\"monitor endian little\\\"\", \"ignoreFailures\": false },\n                { \"text\": \"-interpreter-exec console \\\"monitor reset\\\"\", \"ignoreFailures\": false },\n                { \"text\": \"-interpreter-exec console \\\"monitor halt\\\"\", \"ignoreFailures\": false },\n                { \"text\": \"-interpreter-exec console \\\"monitor arm semihosting enable\\\"\", \"ignoreFailures\": false },\n                { \"text\": \"-target-download\", \"description\": \"flash target\", \"ignoreFailures\": false }\n            ],\n            \"logging\": {\n                \"moduleLoad\": true,\n                \"trace\": true,\n                \"engineLogging\": true,\n                \"programOutput\": true,\n                \"exceptions\": true\n            },\n            \"linux\": {\n                \"MIMode\": \"gdb\",\n                \"MIDebuggerPath\": \"arm-none-eabi-gdb\",\n                \"debugServerPath\": \"pyocd-gdbserver\"\n            },\n            \"osx\": {\n                \"MIMode\": \"gdb\",\n                \"MIDebuggerPath\": \"arm-none-eabi-gdb\",\n                \"debugServerPath\": \"pyocd-gdbserver\"\n            },\n            \"windows\": {\n                \"preLaunchTask\": \"make.exe\",\n                \"MIMode\": \"gdb\",\n                \"MIDebuggerPath\": \"arm-none-eabi-gdb.exe\",\n                \"debugServerPath\": \"pyocd-gdbserver.exe\",\n                \"setupCommands\": [\n                    { \"text\": \"-environment-cd ${workspaceRoot}\\\\armgcc\\\\_build\" },\n                    { \"text\": \"-target-select remote localhost:3333\", \"description\": \"connect to target\", \"ignoreFailures\": false },\n                    { \"text\": \"-file-exec-and-symbols nrf52840_xxaa.out\", \"description\": \"load file\", \"ignoreFailures\": false},\n                    { \"text\": \"-interpreter-exec console \\\"monitor endian little\\\"\", \"ignoreFailures\": false },\n                    { \"text\": \"-interpreter-exec console \\\"monitor reset\\\"\", \"ignoreFailures\": false },\n                    { \"text\": \"-interpreter-exec console \\\"monitor halt\\\"\", \"ignoreFailures\": false },\n                    { \"text\": \"-interpreter-exec console \\\"monitor arm semihosting enable\\\"\", \"ignoreFailures\": false },\n                    { \"text\": \"-target-download\", \"description\": \"flash target\", \"ignoreFailures\": false }\n                ]\n            }\n        }\n    ]\n}\n</code></pre> </li> <li> <p>Create a make task in <code>.vscode/tasks.json</code> file:</p> <pre><code>{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"make\",\n            \"options\": {\n                \"cwd\": \"${workspaceRoot}/armgcc\"\n            },\n            \"problemMatcher\": {\n                \"owner\": \"cpp\",\n                \"fileLocation\": [\"relative\", \"${workspaceRoot}\"],\n                \"pattern\": {\n                    \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",\n                    \"file\": 1,\n                    \"line\": 2,\n                    \"column\": 3,\n                    \"severity\": 4,\n                    \"message\": 5\n                }\n            },\n            \"args\": [],\n            \"linux\": {\n                \"command\": \"make\"\n            },\n            \"osx\": {\n                \"command\": \"make\"\n            },\n            \"windows\": {\n                \"command\": \"make.exe\"\n            }\n        }\n    ]\n}\n</code></pre> </li> </ol>"},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/#debugging-your-project","title":"Debugging your project","text":"<p>Connect the board to your PC, click Debug -&gt; Start Debugging , and debugging starts. Click on the Debug Console tab to see the debug output:</p> <p></p> <p>Now you can explore the debugging capabilities for Variables, Breakpoints, and more.</p>"},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/#example-sources","title":"Example Sources","text":"<p>The example project files are located in GitHub: https://github.com/makerdiary/nrf52840-mdk/tree/master/examples/nrf5-sdk/blinky</p>"},{"location":"debugging-nrf52840-mdk-board-with-visual-studio-code/#reference","title":"Reference","text":"<ul> <li>VS Code Launch Json Reference</li> <li>VS Code Tasks Documentation</li> <li>nRF52840-MDK Documentation</li> </ul>"},{"location":"documentation-updated---nrf52840-mdk-usb-dongle/","title":"Documentation Updated - nRF52840 MDK USB Dongle","text":"<p>The first commit to the <code>makerdiary/nrf52840-mdk-usb-dongle</code> repository was on Sep 27, 2018. Five years later, nRF52840 MDK USB Dongle has become one of the most popular, open-source nRF52840-based hardware today.</p> <p>We are excited to announce that Documentation v2.0.0 is now available! There are many updates in this version that we hope you'll like, some of the key highlights include:</p> <ul> <li>Updated Quick Start Guide - Provide a quick introduction to using nRF Connect Bluetooth Low Energy app to demonstrate Bluetooth Low Energy connectivity.</li> <li>Migrated to nRF Connect SDK - nRF Connect SDK is the latest software development kit for building products based on Nordic Semiconductor's chips. We provide an extensive set of documentation and samples to help you getting started.</li> <li>Added nRF Sniffer for Bluetooth LE - This is a useful tool for debugging and learning about Bluetooth Low Energy applications.</li> <li>Added nRF Sniffer for 802.15.4 - This is a tool for learning about and debugging applications that are using protocols based on IEEE 802.15.4, such as Thread and Zigbee.</li> <li>Updated OpenSK - There are many updates since we landed OpenSK. Now you can try the latest OpenSK firmware, even build your own's.</li> </ul> <p>What's still missing from the updates? Feel free to share your ideas in the Discussions. Together, we can make this project better!</p> <p>Last but certainly not least, a big Thank You to the contributors of this project.</p>"},{"location":"getting-started-with-google-opensk/","title":"Getting started with Google OpenSK","text":""},{"location":"getting-started-with-google-opensk/#getting-started-with-google-opensk","title":"Getting started with Google OpenSK","text":""},{"location":"getting-started-with-google-opensk/#introduction","title":"Introduction","text":"<p>OpenSK released by Google is a fully open-source implementation for security keys written in Rust that supports both FIDO U2F and FIDO2 standards.</p> <p>OpenSK is based on the FIDO2 specifications, which combine the World Wide Web Consortium\u2019s (W3C) Web Authentication (WebAuthn) specification and FIDO Alliance\u2019s corresponding Client-to-Authenticator Protocol (CTAP).</p> <p>The nRF52840 MDK USB Dongle works well with OpenSK. Taking advantage of the UF2 Bootloader, you can easily program the OpenSK by just copying the <code>.uf2</code>-format image to the flash drive.</p> <p>This guide details how to get started with the OpenSK using the nRF52840 MDK USB Dongle without going through the complete toolchain installation.</p>"},{"location":"getting-started-with-google-opensk/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 MDK USB Dongle(or w/Case option)</li> <li>Latest version of Google Chrome, Mozilla Firefox, Microsoft Edge or Apple Safari</li> </ul>"},{"location":"getting-started-with-google-opensk/#programming-the-latest-opensk-firmware","title":"Programming the latest OpenSK firmware","text":"<p>Download the latest firmware and complete the following steps to program the firmware:</p> <ol> <li>Push and hold the button and plug your dongle into the USB port of your computer. Release the button after your dongle is connected. The RGB LED turns green.</li> <li>It will mount as a Mass Storage Device called UF2BOOT.</li> <li>Drag and drop <code>opensk-nrf52840_mdk_usb_dongle-&lt;version&gt;.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</li> <li>Re-plug the dongle and the OpenSK device will start running.</li> </ol> <p>About the Volume Label</p> <p>The dongle manufactured after July 20 2023 is shipped with the latest UF2 Bootloader 0.7.1, which will mount as a Mass Storage Device called UF2BOOT. If you are running the older bootloader, it will mount as MDK-DONGLE.</p>"},{"location":"getting-started-with-google-opensk/#testing-opensk","title":"Testing OpenSK","text":"<p>After flashing the firmware to your dongle, complete the following steps to test it:</p> <ol> <li>Visit https://webauthn.io/ in a supported web browser, for example, Google Chrome.</li> <li> <p>Enter an example username and then click Register. You will be prompted to choose the way to create a passkey. Select USB security key.     </p> </li> <li> <p>Plug the dongle into the USB port of your computer. Red LED and Blue LED are blinking, which asks you to confirm the transaction with a button press.</p> </li> <li> <p>After the button is pressed, you will be prompted to enter a PIN for your security key. Just enter your PIN and click Next.     </p> </li> <li> <p>Red LED and Blue LED are blinking again and press the button again to complete the request. Then you will see the success notification.     </p> </li> <li> <p>Now try to authenticate by click Authenticate. You will be prompted to enter the PIN you set above. Just enter your PIN and click Next.     </p> </li> <li> <p>Red LED and Blue LED are blinking and you are asked to confirm the request with a button press. Press the button and you will be logged in.     </p> </li> </ol>"},{"location":"getting-started-with-google-opensk/#explore-more","title":"Explore More","text":"<p>The two-factor authentication (2FA) has been successfully deployed by a growing number of websites and platforms, including Google, social networks, cloud providers, and many others. Happy trying!</p>"},{"location":"getting-started-with-nrf52840-mdk/","title":"Getting started with nRF52840-MDK","text":""},{"location":"getting-started-with-nrf52840-mdk/#getting-started-with-nrf52840-mdk","title":"Getting started with nRF52840-MDK","text":""},{"location":"getting-started-with-nrf52840-mdk/#introduction","title":"Introduction","text":"<p>The nRF52840-MDK is a versatile, easy-to-use IoT hardware platform for Bluetooth 5, Bluetooth Mesh, Thread, IEEE 802.15.4, ANT and 2.4GHz proprietary applications using the nRF52840 SoC.</p> <p>It comes with a fully integrated debugger (also known as DAPLink) which makes it easy to program and debug application software without extra debug probe.</p> <p>In this post I\u2019ll show you how to connect and set up your nRF52840-MDK, and what to expect when you do so. This will take about 20 minutes.</p>"},{"location":"getting-started-with-nrf52840-mdk/#prerequisites","title":"Prerequisites","text":"<p>In order to set up the nRF52840-MDK development kit, prepare the following:</p> <ul> <li>The nRF52840-MDK board</li> <li>A macOS/Linux/Windows PC</li> <li>An iPhone or Android phone</li> <li>1x USB-C cable</li> </ul> <p></p>"},{"location":"getting-started-with-nrf52840-mdk/#set-up-the-board","title":"Set up the board","text":"<p>Connect the board by performing the following steps:</p> <ol> <li>Connect the nRF52840-MDK to one of your PC\u2019s USB host ports. This provides power to the board. Observe that two GREEN LEDs are on. One indicates that USB power is good, and another indicates that the application is advertising.</li> <li>Open a file explorer. Confirm that the board has appeared as a removable drive named DAPLINK. This allows you to program the nRF52840 chip. You\u2019ll do this under how to program nRF52840-MDK below.</li> </ol> <p></p>"},{"location":"getting-started-with-nrf52840-mdk/#use-terminal-application","title":"Use Terminal application","text":"<p>Terminal applications (for example PuTTY or screen) run on your host PC. They provide a window where the board prints log information.</p> <p>Start a terminal application. The default setup for the USB serial port is 115200 baud, 8 bits, 1 stop bit, no parity (<code>115200\u20138-N-1</code>). For example on macOS, type the following command:</p> <pre><code>screen /dev/cu.usbmodem1412 115200\n</code></pre> <p></p>"},{"location":"getting-started-with-nrf52840-mdk/#use-nrf-connect-app","title":"Use nRF Connect App","text":"<p>You can also test the application with the nRF Connect mobile app by performing the following steps:</p> <ul> <li>Get the nRF Connect app from App Store or Google Play.</li> <li>Connect to the device from nRF Connect (the device is advertising as nRF52840-MDK).</li> <li>Observe that the RGB LED stays BLUE. This indicates that the connections is established.</li> <li>bserve that the LED Button Service is shown in the connected device. It contains two characteristics: Nordic Blinky Button and Nordic Blinky LED.</li> <li>Enable Notify on the Nordic Blinky Button. Notifications are received when pressing or releasing the USER Button.</li> <li>Write <code>01</code> to the Nordic Blinky LED and observe that RED LED is turned on.</li> <li>Write <code>00</code> to the Nordic Blinky LED and observe that RED LED is turned off.</li> </ul> <p></p>"},{"location":"getting-started-with-nrf52840-mdk/#how-to-program-nrf52840-mdk","title":"How to program nRF52840-MDK","text":"<p>You have the following two options to program your board:</p> <ul> <li>Drag-n-drop Programming</li> <li>Using pyOCD</li> </ul>"},{"location":"getting-started-with-nrf52840-mdk/#drag-n-drop-programming","title":"Drag-n-drop Programming","text":"<p>Drag and drop the hex file into the DAPLINK removable drive. The file contains firmware which will be automatically programmed onto the nRF52840 SoC. When programming is completed, the removable drive will be re-detected by the computer. The application will run after pressing the RESET button.</p> <p></p>"},{"location":"getting-started-with-nrf52840-mdk/#using-pyocd","title":"Using pyOCD","text":"<p>pyOCD is an open source Python package for programming and debugging Arm Cortex-M microcontrollers using multiple supported types of USB debug probes. It is fully cross-platform, with support for Linux, macOS, and Windows.</p> <p>The latest stable version of pyOCD may be installed via pip as follows:</p> <pre><code>pip install -U pyocd\n</code></pre> <p>For more installing options, see pyOCD GitHub repo.</p> <p>Verify if your board is detected by pyOCD by running:</p> <pre><code>pyocd list\n</code></pre> <p>Flash the board with your new firmware by running:</p> <pre><code>pyocd flash -t nrf52840 &lt;path-to-your-firmware.hex&gt;\n</code></pre> <p></p>"},{"location":"getting-started-with-nrf52840-mdk/#next-steps","title":"Next steps","text":"<p>You can clone the makerdiary/nrf52840-mdk repository or download it as a zip package and put its contents to your working directory.</p> <pre><code>git clone https://github.com/makerdiary/nrf52840-mdk.git\n</code></pre> <p>This repository provides documents and example applications that you can run on your board to ensure that everything is set up correctly.</p>"},{"location":"getting-started-with-nrf52840-mdk/#resources","title":"Resources","text":"<ul> <li>nRF52840-MDK GitHub Repository</li> <li>nRF52840-MDK Wiki Page</li> </ul>"},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/","title":"How to set up nRF5 SDK with ARM GCC","text":""},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/#how-to-set-up-nrf5-sdk-with-arm-gcc","title":"How to set up nRF5 SDK with ARM GCC","text":""},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/#introduction","title":"Introduction","text":"<p>The nRF5 SDK is your first stop for building fully featured, reliable and secure applications with the nRF52 and nRF51 Series. It offers developers a wealth of varied modules and examples right across the spectrum including numerous Bluetooth Low Energy profiles, Device Firmware Upgrade (DFU), GATT serializer and driver support for all peripherals on all nRF5 Series devices. The nRF5 SDK will almost certainly have something for your needs in developing exciting yet robust wireless products.</p> <p>The SDK is delivered as a plain <code>.zip</code>-archive, which makes it easy to install as well as giving you the freedom to choose the IDE and compiler of your choice.</p> <p>Here we will describe how to set up the nRF5 SDK development environment on your system, build and run the example applications.</p>"},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/#install-gnu-arm-embedded-toolchain","title":"Install GNU Arm Embedded Toolchain","text":"<p>The GNU Embedded Toolchain for Arm is a ready-to-use, open source suite of tools for C, C++ and Assembly programming targeting Arm Cortex-M and Cortex-R family of processors. It includes the GNU Compiler (GCC) and is available free of charge directly from Arm for embedded software development on Windows, Linux and macOS operating systems.</p> <p>Download and install the GNU ARM Embedded Toolchain. The <code>6-2017-q2-update</code> version is recommended. Then ensure the path is added to your OS PATH environment variable.</p> <pre><code># in ~/.bash_profile, add the following script\nexport PATH=\"&lt;path to install directory&gt;/gcc-arm-none-eabi-6-2017-q2-update/bin:${PATH}\"\n</code></pre> <p>Type the following in your terminal to verify if the path is set correctly:</p> <pre><code>arm-none-eabi-gcc --version\n</code></pre>"},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/#install-gnu-make","title":"Install GNU make","text":"<p>Now with the toolchain installed we can build object files from source code, but to build projects based on makefiles, which can be seen as a recipes for the builds, we need to have GNU make installed on the system.</p> <p>On Windows the easiest way to install the dependencies is to use the MSYS2. You can do so by performing the following steps:</p> <ol> <li> <p>Download and run the installer - \"x86_64\" for 64-bit, \"i686\" for 32-bit Windows.</p> </li> <li> <p>Update the package database and core system packages with:     <pre><code>pacman -Syu\n</code></pre></p> </li> <li> <p>If needed, close MSYS2, run it again from Start menu. Update the rest with:     <pre><code>pacman -Su\n</code></pre></p> </li> <li> <p>Install make:     <pre><code>pacman -S make\n</code></pre></p> </li> </ol> <p>GNU make is bundled with Xcode tools if working on macOS. On Linux it may be different ways to obtain GNU make depending on your distro, if not installed already, e.g. on Ubuntu you can get by entering this command:</p> <pre><code>sudo apt-get install build-essential checkinstall\n</code></pre>"},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/#clone-the-repository","title":"Clone the repository","text":"<p>Clone the nRF52840-MDK repository from GitHub:</p> <pre><code>git clone https://github.com/makerdiary/nrf52840-mdk\n</code></pre>"},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/#install-the-nrf5-sdk","title":"Install the nRF5 SDK","text":"<p>Download the SDK file nRF5_SDK_v15.2.0_9412b96 from https://www.nordicsemi.com . Note that the current version is <code>15.2.0</code>.</p> <p>Extract the zip file to the <code>nrf52840-mdk/nrf_sdks</code> directory. This should give you the following folder structure:</p> <pre><code>./nrf52840-mdk/\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 firmware\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 docs\n\u251c\u2500\u2500 examples\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 nrf_sdks\n\u2502   \u2514\u2500\u2500 nRF5_SDK_v15.2.0_9412b96\n\u2514\u2500\u2500 tools\n</code></pre> <p>To build an example application you first need to set the toolchain path in <code>makefile.windows</code> or <code>makefile.posix</code> depending on platform you are using. That is, the <code>.posix</code> should be edited if your are working on either Linux or macOS. These files are located in:</p> <pre><code>&lt;SDK&gt;/components/toolchain/gcc\n</code></pre> <p>Open the file in a text editor, and make sure that the GNU_INSTALL_ROOT variable is pointing to your GNU Arm Embedded Toolchain install directory.</p> <pre><code>GNU_INSTALL_ROOT ?= $(HOME)/gcc-arm-none-eabi/gcc-arm-none-eabi-6-2017-q2-update/bin/\nGNU_VERSION ?= 6.3.1\nGNU_PREFIX ?= arm-none-eabi\n</code></pre>"},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/#build-and-run-the-blinky-example","title":"Build and run the blinky example","text":"<p>Now you can try to build one of the examples. Will use the blinky example here to keep it simple.</p> <p>Open terminal and change directory to:</p> <pre><code>cd ./nrf52840-mdk/examples/nrf5-sdk/blinky/armgcc/\n</code></pre> <p>Connect the nRF52840-MDK to one of your PC's USB host ports. Compile and program the example:</p> <pre><code>make flash\n</code></pre> <p></p>"},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/#run-examples-with-softdevice","title":"Run examples with SoftDevice","text":"<p>Before you can run more advanced examples that use Bluetooth or ANT, you must program the SoftDevice on the board.</p> <p>The SoftDevice binary is located in folder <code>components/softdevice/&lt;Softdevice&gt;/hex</code> in the SDK, where <code>&lt;Softdevice&gt;</code> is the name of the SoftDevice.</p> <p>The easiest way to program the SoftDevice is using the GCC makefile of an example:</p> <ol> <li> <p>Open a command prompt in the folder that contains the makefile of an example. The example must require a SoftDevice. For example, the <code>ble_app_blinky</code> example.</p> <pre><code># change to the armgcc directory of 'ble_app_blinky' example\ncd ~/nrf52840-mdk/examples/nrf5-sdk/ble_app_blinky/armgcc\n</code></pre> </li> <li> <p>Run the following command:</p> <pre><code># this will compile &amp; program the application(without SoftDevice)\nmake flash\n\n# this will program SoftDevice alone\nmake flash_softdevice\n</code></pre> </li> </ol> <p></p>"},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/#more-examples","title":"More examples","text":"<p>Over time, more example applications will be added to the repository. You can star or watch the nrf52840-mdk repository to stay up to date.</p>"},{"location":"how-to-set-up-nrf5-sdk-with-arm-gcc/#reference","title":"Reference","text":"<ul> <li>Nordic nRF5 SDK</li> <li>Nordic Semiconductor Infocenter</li> <li>makerdiary/nrf52840-mdk repository</li> <li>nRF52840 MDK Documentation</li> </ul>"},{"location":"imx-rt1011-nano-kit-is-here/","title":"iMX RT1011 Nano Kit is Here!","text":""},{"location":"imx-rt1011-nano-kit-is-here/#overview","title":"Overview","text":"<p>We are excited to announce the iMX RT1011 Nano Kit, a small and high-performing prototyping kit designed around NXP's iMX RT1011 Crossover MCU based on the Arm Cortex-M7 core, which operates at speeds up to 500 MHz to provide high CPU performance and best real-time response.</p> <p>iMX RT1011 Nano Kit comes in the same form factor we first introduced in our nRF52840 Connect Kit, and provides external 128 Mbit QSPI flash with XIP support, flexible power management, programmable LED and Button, up to 33 multi-function GPIO pins (15 can be configured as ADC inputs) and Serial Wire Debug (SWD) port.</p> <p></p>"},{"location":"imx-rt1011-nano-kit-is-here/#imx-rt1011-crossover-mcu","title":"iMX RT1011 Crossover MCU","text":"<p>The iMX RT1011 is a member of NXP's iMX RT real-time processor family based on the Arm\u00ae Cortex\u00ae-M7 core, which operates at speeds up to 500 MHz to provide high CPU performance and best real-time response. It has 128 KB on-chip RAM that can be flexibly configured as TCM or general-purpose as well as numerous peripherals including high speed USB, UART, SPI, I2C, SAI, PWM, GPIO, ADC and etc to support a wide range of applications.</p> <p></p>"},{"location":"imx-rt1011-nano-kit-is-here/#easy-firmware-update","title":"Easy firmware update","text":"<p>iMX RT1011 Nano Kit is shipped with the UF2 Bootloader, which is an easy-to-use and self-upgradable bootloader that can be used to update the firmware by just copying the .uf2-format images to the flash drive.</p> <p>In addition, you can always enter the ROM Serial Downloader even when the UF2 Bootloader gets corrupted somehow and use the MCUXpresso Secure Provisioning Tool to build and write the images to the board.</p>"},{"location":"imx-rt1011-nano-kit-is-here/#zephyr-rtos-support","title":"Zephyr RTOS support","text":"<p>The Zephyr Project is a Linux Foundation hosted Collaboration Project. It\u2019s an open-source collaborative effort uniting developers and users in building a best-in-class small, scalable real\u2043time operating system (RTOS) optimized for resource-constrained devices, across multiple architectures.</p> <p>Zephyr RTOS support is available on iMX RT1011 Nano Kit. To quickly get started with the Zephyr RTOS application development, refer to our Develop with Zephyr RTOS guide.</p>"},{"location":"imx-rt1011-nano-kit-is-here/#circuitpython-support","title":"CircuitPython support","text":"<p>Python is a high-level programming language which means it's designed to be easier to read, write and maintain. It has a built-in interpreter which means there are no extra steps, like compiling, to get your code to work.</p> <p>iMX RT1011 Nano Kit can run CircuitPython which allows you to access hardware-specific functionality and peripherals with Python programming language. With CircuitPython, there are no upfront desktop downloads needed. Once you get your board set up, open any text editor, and start editing code. It's that simple. To get started with CircuitPython, check our Code in Python guide.</p>"},{"location":"imx-rt1011-nano-kit-is-here/#get-involved","title":"Get Involved","text":"<p>Interested in our brand new iMX RT1011 Nano Kit? You can get it from the official store or refer to our wiki page for more technical resources.</p>"},{"location":"interface-mcu-on-nrf54l15-connect-kit/","title":"Interface MCU on nRF54L15 Connect Kit","text":""},{"location":"interface-mcu-on-nrf54l15-connect-kit/#introducing-interface-mcu","title":"Introducing Interface MCU","text":""},{"location":"interface-mcu-on-nrf54l15-connect-kit/#introduction","title":"Introduction","text":"<p>The nRF54L15 Connect Kit comes with an nRF52820-based Interface MCU. The Interface MCU Firmware is running on the nRF52820. It implements a CMSIS-DAP interface for debugging and programming the nRF54L15. It also exposes two USB CDC ACM devices, one acts as a UART bridge between the host and the nRF54L15, the other enables an Interface Shell for accessing board-specific functionality.</p> <p>The Interface MCU also comes pre-programmed with the UF2 Bootloader, an easy-to-use and self-upgradable bootloader that can be used to update the firmware by just copying the .uf2-format images to the flash drive without using an external programmer.</p> <p>The following figure describes the functional architecture of the Interface MCU:</p> <p></p> <p></p>"},{"location":"interface-mcu-on-nrf54l15-connect-kit/#why-choose-the-nrf52820","title":"Why Choose the nRF52820","text":"<p>The nRF52820, with its rich feature set and low-power design, is an excellent choice for implementing an Interface MCU.</p> <ul> <li>Low Power Consumption: Ultra-low power is in Nordic's DNA. The nRF52820 draws less than 1 \u00b5A in System OFF mode, making it an ideal choice for battery-powered applications.</li> <li>High Performance: The nRF52820 features a 64 MHz Arm Cortex-M4 processor with 256 KB Flash and 32 KB RAM.</li> <li>Full Speed USB 2.0: The nRF52820 integrates a USB 2.0 full speed (12 Mbps) controller, which allows the SoC to support multiple functions, such as HID and CDC, simultaneously.</li> <li>Cost-Effective: The nRF52820 integrates many features into a single chip, reducing the need for additional external components. This integration lowers the overall Bill of Materials (BOM).</li> <li>Comprehensive Development Ecosystem: Compatible with Nordic\u2019s nRF Connect SDK. This makes it easier to develop and debug applications.</li> </ul>"},{"location":"interface-mcu-on-nrf54l15-connect-kit/#getting-started-with-the-interface-mcu","title":"Getting Started with the Interface MCU","text":"<p>The Interface MCU firmware is open source, and detailed documentation is available to help you get started.</p> <ul> <li>Interface MCU Firmware Source Code</li> <li>Interface MCU Firmware Documentation</li> </ul>"},{"location":"introducing-circuitpython/","title":"Introducing CircuitPython","text":""},{"location":"introducing-circuitpython/#what-is-circuitpython","title":"What is CircuitPython?","text":"<p>CircuitPython is a programming language designed to simplify experimenting and learning to program on low-cost microcontroller boards. It makes getting started easier than ever with no upfront desktop downloads needed. Once you get your board set up, open any text editor, and get started editing code. It's that simple.</p> <p>CircuitPython is an implementation of Python, which is a high-level programming language which means it's designed to be easier to read, write and maintain. It supports modules and packages which means it's easy to reuse your code for other projects. It has a built in interpreter which means there are no extra steps, like compiling, to get your code to work. And of course, it is Open Source Software which means it's free for anyone to use, modify or improve upon.</p>"},{"location":"introducing-circuitpython/#why-circuitpython","title":"Why CircuitPython?","text":"<p>CircuitPython is a fork of MicroPython, and offers unified Python core APIs and a growing list of 300+ device libraries and drivers that work with it. You can see differences from MicroPython.</p> <p>Here is some reasons to use CircuitPython:</p> <ul> <li>You want to get up and running quickly. Create a file, edit your code, save the file, and it runs immediately. There is no compiling, no downloading and no uploading needed.</li> <li>You're new to programming. CircuitPython is designed with education in mind. It's easy to start learning how to program and you get immediate feedback from the board.</li> <li>Easily update your code. Since your code lives on the disk drive, you can edit it whenever you like, you can also keep multiple files around for easy experimentation.</li> <li>The serial console and REPL. These allow for live feedback from your code and interactive programming. File storage. The internal storage for CircuitPython makes it great for data-logging, playing audio clips, and otherwise interacting with files.</li> <li>Strong hardware support. CircuitPython has builtin support for microcontroller hardware features like digital I/O pins, hardware buses (UART, I2C, SPI), audio I/O, and other capabilities. There are also many libraries and drivers for sensors, breakout boards and other external components.</li> <li>It's Python! Python is the fastest-growing programming language. It's taught in schools and universities. CircuitPython is almost-completely compatible with Python. It simply adds hardware support.</li> </ul>"},{"location":"introducing-circuitpython/#how-to-get-started","title":"How to get started?","text":"<p>To use CircuitPython, you need to choose a microcontroller board well supported by CircuitPython. There are 300+ boards that can run CircuitPython.</p> <p>The following boards from Makerdiary are supported by CircuitPython:</p> <ul> <li>nRF52840 Connect Kit</li> <li>nRF52840 MDK USB Dongle(we also have a w/Case version)</li> <li>nRF52840 M.2 Developer Kit</li> <li>M60 Mechanical Keyboard</li> <li>Pitaya Go</li> <li>nRF52840 MDK</li> </ul>"},{"location":"introducing-interface-mcu/","title":"Introducing Interface MCU","text":""},{"location":"introducing-interface-mcu/#introducing-interface-mcu","title":"Introducing Interface MCU","text":""},{"location":"introducing-interface-mcu/#introduction","title":"Introduction","text":"<p>The nRF9151 Connect Kit comes with an on-board Interface MCU built using the nRF52820. The Interface MCU Firmware is running on the nRF52820. It implements a CMSIS-DAP interface for debugging and programming the nRF9151 SiP. It also exposes two USB CDC ACM devices, one acts as a UART bridge between the host and the nRF9151 SiP, the other enables an Interface Shell for accessing board-specific functionality such as battery charger settings.</p> <p>The Interface MCU also comes pre-programmed with the UF2 Bootloader, an easy-to-use and self-upgradable bootloader that can be used to update the firmware by just copying the .uf2-format images to the flash drive without using an external programmer.</p> <p>The following figure describes the functional architecture of the Interface MCU:</p> <p></p>"},{"location":"introducing-interface-mcu/#why-choose-the-nrf52820","title":"Why Choose the nRF52820","text":"<p>The nRF52820, with its rich feature set and low-power design, is an excellent choice for implementing an Interface MCU.</p> <ul> <li>Low Power Consumption: Ultra-low power is in Nordic's DNA. The nRF52820 draws less than 1 \u00b5A in System OFF mode, making it an ideal choice for battery-powered applications.</li> <li>High Performance: The nRF52820 features a 64 MHz Arm Cortex-M4 processor with 256 KB Flash and 32 KB RAM.</li> <li>Full Speed USB 2.0: The nRF52820 integrates a USB 2.0 full speed (12 Mbps) controller, which allows the SoC to support multiple functions, such as HID and CDC, simultaneously.</li> <li>Cost-Effective: The nRF52820 integrates many features into a single chip, reducing the need for additional external components. This integration lowers the overall Bill of Materials (BOM).</li> <li>Comprehensive Development Ecosystem: Compatible with Nordic\u2019s nRF Connect SDK. This makes it easier to develop and debug applications.</li> </ul>"},{"location":"introducing-interface-mcu/#getting-started-with-the-interface-mcu","title":"Getting Started with the Interface MCU","text":"<p>The Interface MCU firmware is open source, and detailed documentation is available to help you get started.</p> <ul> <li>Interface MCU Firmware Source Code</li> <li>Interface MCU Firmware Documentation</li> </ul>"},{"location":"introducing-nrf-cloud/","title":"Introducing nRF Cloud","text":""},{"location":"introducing-nrf-cloud/#introducing-nrf-cloud","title":"Introducing nRF Cloud","text":""},{"location":"introducing-nrf-cloud/#what-is-nrf-cloud","title":"What is nRF Cloud?","text":"<p>nRF Cloud is a comprehensive cloud platform tailored for IoT developers. It bridges the gap between IoT devices and the cloud, offering a suite of services that streamline the entire development lifecycle. Whether you\u2019re building a small-scale prototype or a large-scale deployment, nRF Cloud provides the infrastructure and tools to make your IoT vision a reality.</p> <p></p>"},{"location":"introducing-nrf-cloud/#key-features-of-nrf-cloud","title":"Key Features of nRF Cloud","text":"<ul> <li> <p>Device Management: Easily onboard, monitor, and manage your IoT devices at scale. Track device health, connectivity status, and performance in real-time.</p> </li> <li> <p>Data Visualization: Transform raw sensor data into actionable insights with customizable dashboards. Visualize trends, anomalies, and key metrics to make informed decisions.</p> </li> <li> <p>Over-the-Air (OTA) Updates: Securely deploy firmware updates to devices in the field, ensuring they stay up-to-date with the latest features and security patches.</p> </li> <li> <p>Seamless Integration: Fully compatible with Nordic\u2019s nRF91 Series and nRF Connect SDK.</p> </li> <li> <p>Security: Built-in security features, including end-to-end encryption and secure boot, protect your devices and data from threats.</p> </li> <li> <p>Scalability: Allow you to seamlessly scale from a few devices on a pilot run to thousands of devices on a production deployment.</p> </li> </ul>"},{"location":"introducing-nrf-cloud/#benefits-of-nrf-cloud","title":"Benefits of nRF Cloud","text":"<ul> <li> <p>Built from the ground-up for low power: Ultra-low power is in Nordic's DNA. Everything we offer to our customers across hardware, software and cloud services, is optimized for ultra-low power. </p> </li> <li> <p>Agnostic connectivity transport: nRF Cloud can be accessed via device-to-cloud or cloud-to-cloud mechanisms, to ensure it fits a variety of use-cases and system architectures.</p> </li> <li> <p>Standalone services and pricing: Individual selection of services and features allows for a flexible adoption that meets your needs, and pricing plan options that fit the scale of your business.</p> </li> <li> <p>Full lifecycle support: nRF Cloud services can be leveraged across your product's entire lifecycle, from production to field decommissioning, reducing costs associated with proprietary infrastructure.</p> </li> </ul>"},{"location":"introducing-nrf-cloud/#getting-started-with-nrf-cloud","title":"Getting Started with nRF Cloud","text":"<p>We think the best way to learn is by doing. We provides the following samples that help you to get started with nRF Cloud on the nRF9151 Connect Kit.</p> <ul> <li> <p>nRF Cloud Device Provisioning</p> <p>Demonstrate how to use the nRF Cloud device provisioning service.</p> </li> <li> <p>nRF Cloud REST Device Message</p> <p>Demonstrate how to use the nRF Cloud REST API to send Device Messages.</p> </li> <li> <p>nRF Cloud Multi-service</p> <p>Demonstrate how to integrate multiple nRF Cloud services.</p> </li> </ul>"},{"location":"introducing-nrf-connect-sdk/","title":"Introducing nRF Connect SDK","text":""},{"location":"introducing-nrf-connect-sdk/#introducing-nrf-connect-sdk","title":"Introducing nRF Connect SDK","text":""},{"location":"introducing-nrf-connect-sdk/#overview","title":"Overview","text":"<p>nRF Connect SDK is a scalable and unified software development kit for building products based on Nordic Semiconductor's nRF52, nRF53, nRF70 and nRF91 Series wireless devices. It offers developers an extensible framework for building size-optimized software for memory-constrained devices as well as powerful and complex software for more advanced devices and applications.</p> <p>It integrates the Zephyr Real-Time Operating System (RTOS) and a wide range of complete applications, samples, and protocol stacks such as Bluetooth Low Energy, Bluetooth mesh, Matter, Thread/Zigbee and LTE-M/NB-IoT/GPS, TCP/IP. It also includes middleware such as CoAP, MQTT, LwM2M, various libraries, hardware drivers, Trusted Firmware-M for security, and a secure bootloader (MCUBoot).</p> <p>The following figure illustrates the architecture of the nRF Connect SDK, where Zephyr RTOS and third-party components (Ex: MCUBoot, Trusted Firmware-M) are shown in dark blue:</p> <p></p>"},{"location":"introducing-nrf-connect-sdk/#about-zephyr-rtos","title":"About Zephyr RTOS","text":"<p>Zephyr RTOS is an open-source real-time operating system for connected and resource-constrained embedded devices. It includes a scheduler that ensures predictable/deterministic execution patterns and abstracts out the timing requirements. It also comes with a rich set of fundamental libraries and middleware that simplifies development and helps reduce a product\u2019s time to market. Zephyr RTOS is highly configurable and enables scalable configurations from very small configurations for memory-constrained devices (minimum 8 kilobytes, for example, simple LED blinking application) to powerful, feature-rich, high-processing power devices (multiple MBs of memory) with large memory configurations.</p> <p>Zephyr RTOS</p>"},{"location":"introducing-nrf-connect-sdk/#how-nrf-connect-sdk-code-is-organized","title":"How nRF Connect SDK code is organized","text":"<p>The nRF Connect SDK offers a single code base for all of Nordic\u2019s devices and software components. It simplifies porting modules, libraries, and drivers from one application to another, thus reducing development time. By enabling developers to pick and choose the essential software components for their application, high memory efficiency is guaranteed. The nRF Connect SDK is publicly hosted on GitHub.</p> <p>Internally, the nRF Connect SDK code is organized into four main repositories:</p> <ul> <li>nrf \u2013 Applications, samples, connectivity protocols (Nordic)</li> <li>nrfxlib \u2013 Common libraries and stacks (Nordic)</li> <li>Zephyr \u2013 RTOS &amp; Board configurations (open source)</li> <li>MCUBoot \u2013 Secure Bootloader (open source)</li> </ul> <p>In addition to the four main repositories, there are also other repositories like the TrustedFirmware-M repository and the Matter repository.</p>"},{"location":"introducing-nrf-connect-sdk/#tools-and-configuration","title":"Tools and configuration","text":"<p>The figure below visualizes the toolchain in the nRF Connect SDK, which is based on the Zephyr toolchain. You can see a set of different tools, each playing a role in the creation of an application, from configuring the system to building it.</p> <p></p> <p>Kconfig generates definitions that configure the whole system, for example which wireless protocol or which libraries to include in your application. Devicetree describes the hardware. CMake then uses the information from Kconfig and the devicetree to generate build files, which Ninja will use to build the program. The GCC compiler system is used to create the executables.</p> <p>This high decoupling of the source code (<code>*.c</code>) and the configuration system through Kconfig (<code>*.conf</code>) and the hardware description system through devicetree (<code>*.dts</code>) makes it easy to use the same application source code on different hardware and with different configurations with minimal changes. This has a huge impact on the ease of portability and maintainability.</p> <p></p>"},{"location":"introducing-nrf-connect-sdk/#next-steps","title":"Next steps","text":"<p>Now that we have an understanding of the content and structure of the nRF Connect SDK, let\u2019s move to the developer guides which will step you through the basics of nRF Connect SDK development and show you how to implement typical use cases with Nordic Semiconductor libraries and drivers on nRF52840 Connect Kit.</p> <p>nRF Connect SDK Developer Guides</p>"},{"location":"meet-m60-mechanical-keyboard---from-prototype-to-production/","title":"Meet M60 Mechanical Keyboard - from Prototype to Production","text":""},{"location":"meet-m60-mechanical-keyboard---from-prototype-to-production/#meet-m60-mechanical-keyboard-from-prototype-to-production","title":"Meet M60 Mechanical Keyboard - from Prototype to Production","text":"<p>A few months ago, we made a hand-wired keyboard powered by Python, which attracted a lot of attention. Lots of people love it, some question it. With putting more time into the Python keyboard, we find it more and more interesting. We think a Python keyboard can make a big difference, so we decided to design a new keyboard for everyone. It's called M60.</p> <p>Designing a new keyboard is a step by step process. Now, we has finished keyboard PCBA design. We would like to share the process and some ideas behind it with you.</p> <p>The hand-wired keyboard is a typical prototype. It is a working keyboard and can be used to do some function tests. It has got some feedback. From these feedback, we know that soldering a keyboard is a really hard for most people, so M60 is a solder-free keyboard. It has hot-swapping sockets which makes it super easy to change mechanical switches. You will be able to choose your favorite type of mechanical switches.</p> <p></p> <p>With modular design in mind, we designed an M2 module as the core of the keyboard. It is a practice of design for manufacturing, which also improve its repairability.</p> <p>With Python, the keyboard has very unique features. With no need to download any software or setup a development environment, we can just use a text editor to configure the keyboard or to add a new function. Meanwhile, it also has some disadvantages. Comparing to C, Python is slower, it requires more powerful hardware and has higher power consumption.</p> <p>Besides, the keyboard is powerful enough to run Python, will also be able to run C/C++, Rust, Go (TinyGo) and JavaScript (JerryScript). The hardware is also optimized for power efficiency.</p> <p>We always want to get you involved. If you're also interested in the Python keyboard, you can share your idea with us.</p>"},{"location":"nrf52840-connect-kit-is-here/","title":"nRF52840 Connect Kit is Here!","text":""},{"location":"nrf52840-connect-kit-is-here/#nrf52840-connect-kit-is-here","title":"nRF52840 Connect Kit is Here!","text":"<p>We are excited to announce that nRF52840 Connect Kit is now available! It's a new member of our nRF52840-based prototyping kit family. It comes in a more mainstream form factor with USB-C and 40 pin DIP/SMT type. A new power architecture is introduced to support various options for easily powering the unit from USB, external supplies or batteries. We will also offer Chip antenna or U.FL receptacle option for selection.</p> <p></p> <p>With nRF52840 Connect Kit you can quickly and easily build your next connected project supporting Bluetooth LE, Bluetooth mesh, NFC, Thread, Zigbee, 802.15.4, ANT and 2.4 GHz proprietary stacks. Easy-to-use form factor, USB-C, 64 Mbit QSPI flash, flexible power management and a rich set of features enable designs to meet a wide range of applications.</p> <p>About nRF52840</p> <p>The nRF52840 SoC is the most advanced member of the nRF52 Series. It meets the challenges of sophisticated applications that need protocol concurrency and a rich and varied set of peripherals and features. It offers generous memory availability for both Flash and RAM, which are prerequisites for such demanding applications.</p> <p>The nRF52840 is fully multiprotocol capable with full protocol concurrency. It has protocol support for Bluetooth LE, Bluetooth mesh, Thread, Zigbee, 802.15.4, ANT and 2.4 GHz proprietary stacks.</p> <p>nRF52840 Connect Kit has support for Nordic Semi's nRF Connect SDK, which integrates the Zephyr RTOS, protocol stacks, samples, hardware drivers and much more. We also offer Python support, allowing you access hardware-specific functionality and peripherals with Python programming language.</p> <p>In addition, we offer an extensive set of documentation such as out of box experience, getting started and developer guides, which can help you save big by reducing development effort.</p> <p>Interested in our brand new nRF52840 Connect Kit? You can get it from the official store or refer to our wiki page for more technical resources.</p>"},{"location":"nrf54l15-connect-kit-now-available/","title":"nRF54L15 Connect Kit Now Available","text":""},{"location":"nrf54l15-connect-kit-now-available/#nrf54l15-connect-kit-now-available","title":"nRF54L15 Connect Kit Now Available","text":""},{"location":"nrf54l15-connect-kit-now-available/#introduction","title":"Introduction","text":"<p>Today, we\u2019re thrilled to launch the nRF54L15 Connect Kit, enabling developers to harness the advanced capabilities of Nordic\u2019s nRF54L15 SoC for cutting-edge IoT designs.</p> <p>Built on the experience from the successful nRF52 Series\u2014shipped in the billions and trusted by thousands of developers\u2014the nRF54L Series is set to be a worthy successor. The nRF54L Series enables the creation of innovative next-generation IoT products. It simplifies design challenges and ensures reliable wireless communication while raising the bar on achievable battery lifetime.</p>"},{"location":"nrf54l15-connect-kit-now-available/#key-features-of-the-nrf54l15-connect-kit","title":"Key Features of the nRF54L15 Connect Kit","text":"<ul> <li> <p>Powered by nRF54L15 SoC</p> <p>nRF54L15 is a ultra-low-power wireless SoC featuring a 128 MHz Arm Cortex\u00ae-M33 processor and a 128 MHz RISC-V coprocessor with 1.5 MB NVM and 256 KB RAM. It supports Bluetooth LE 6.0, Thread\u00ae, Matter, Zigbee\u00ae, 4 Mbps proprietary 2.4 GHz mode, NFC and enhanced security.</p> </li> <li> <p>On-board Interface MCU</p> <p>Integrate an nRF52820-based Interface MCU for onboard debugging and programming, eliminating the need for external tools. The Interface MCU also includes a USB-UART bridge for log, trace and terminal emulation, and an Interface Shell to access the board-specific functionality.</p> </li> <li> <p>Easy-to-use Form Factor</p> <p>Featuring USB-C, LEDs, Buttons, U.FL receptacles for U.FL cabled 2.4 GHz Antenna and 13.56 MHz NFC Antenna, Arm Serial Wire Debug (SWD) port and dual-row 40 pins with loose or pre-soldered headers available.</p> </li> <li> <p>Flexible Power Management</p> <p>Integrated TPS63901 buck-boost converter with 75-nA quiescent current and 1.8V/3.3V configurable power supply for I/Os, supporting various options for easily powering the unit from USB-C, external supplies or batteries.</p> </li> <li> <p>Built on Open Source</p> <p>nRF Connect SDK is supported, including the Zephyr RTOS. Developers can explore the full potential of the nRF54L15 using the extensive range of software samples, modules, and libraries available within the nRF Connect SDK.</p> </li> <li> <p>Well Documented</p> <p>An extensive set of documentation is available, including getting started and developer guides which can help you save big by reducing development effort. The documentation is hosted as a GitHub repository that allows managing the updates over time.</p> </li> </ul>"},{"location":"nrf54l15-connect-kit-now-available/#getting-started-with-the-nrf54l15-connect-kit","title":"Getting Started with the nRF54L15 Connect Kit","text":"<p>We think the best way to learn is by doing. Our online documentation takes you through the basics of nRF Connect SDK development and show you how to implement typical use cases with Nordic Semiconductor libraries and drivers on the nRF54L15 Connect Kit.</p> <ul> <li> <p> Quick Start Guide</p> <p>Navigate you through the process of starting up your new nRF54L15 Connect Kit.</p> <p> Learn More</p> </li> <li> <p> Develop with nRF Connect SDK</p> <p>Set up the nRF Connect SDK development environment, build and run the tested applications and samples.</p> <p> Learn More</p> </li> <li> <p> Programming Guide</p> <p>Provide comprehensive instructions for programming the nRF54L15 and updating the Interface MCU Firmware.</p> <p> Learn More</p> </li> </ul> <p>Available now! \u2014 Get your nRF54L15 Connect Kit today and start developing the future of connected devices.</p>"},{"location":"nrf9151-connect-kit-is-here/","title":"nRF9151 Connect Kit is Here!","text":""},{"location":"nrf9151-connect-kit-is-here/#nrf9151-connect-kit-is-here","title":"nRF9151 Connect Kit is Here!","text":""},{"location":"nrf9151-connect-kit-is-here/#introduction","title":"Introduction","text":"<p>Today we are excited to launch our latest IoT prototyping kit, the nRF9151 Connect Kit, for LTE-M, NB-IoT, DECT NR+, and GNSS applications. The nRF9151 Connect Kit comes with on-board Interface MCU for debug and programming, flexible power management with battery charger, easy-to-use form factor, nRF Connect SDK support including the Zephyr RTOS, various samples and documentation. It\u2019s designed to help developers quickly prototype and deploy Cellular IoT applications with minimal effort.</p>"},{"location":"nrf9151-connect-kit-is-here/#why-choose-the-nrf9151-sip","title":"Why Choose the nRF9151 SiP","text":"<p>Like its predecessor, the nRF9161, the nRF9151 supports 3GPP release 14 LTE-M/NB-IoT global coverage and DECT NR+. The nRF9151 stands out from the nRF9160 and nRF9161 with its exclusive features, such as a significant footprint reduction, which allows for more compact products without performance compromises. In addition to Power class 3 (23 dBm), the nRF9151 also supports Power class 5 (20 dBm) output power, leading to 45 percent reduced peak power consumption thanks to the unique nRF9151 low power design, which decreases the cost of battery-powered products. The nRF9151 will also add support for Non-Terrestrial Network (NTN) support in a future firmware release.  </p>"},{"location":"nrf9151-connect-kit-is-here/#key-features-of-the-nrf9151-connect-kit","title":"Key Features of the nRF9151 Connect Kit","text":"<ul> <li>Global Cellular Connectivity: Supports LTE-M and NB-IoT networks, ensuring reliable connectivity worldwide.</li> <li>Integrated GNSS: Built-in Global Navigation Satellite System (GNSS) enables precise location tracking for applications like asset tracking.</li> <li>On-board Interface MCU: Built-in CMSIS-DAP support for debug, programming as well as modem firmware update, no need for any external tools.</li> <li>Ultra-Low Power Design: Optimized for battery-powered devices, the kit ensures long operational life, making it ideal for remote and hard-to-reach deployments.</li> <li>Built on Open Source: Compatible with Nordic\u2019s nRF Connect SDK, including the Zephyr RTOS, various samples, networking protocols, libraries, and hardware drivers, all essential for cellular IoT development.</li> </ul>"},{"location":"nrf9151-connect-kit-is-here/#join-the-cellular-iot-revolution","title":"Join the Cellular IoT Revolution","text":"<p>The nRF9151 Connect Kit is here to help you unlock the full potential of cellular IoT. With its advanced features and user-friendly design, it\u2019s the perfect platform for developers looking to innovate and lead in the low power Cellular IoT space.</p> <p>Get your nRF9151 Connect Kit today and start building the future of connected devices!</p>"},{"location":"programming-nrf5x-socs-with-pitaya-link/","title":"Programming nRF5x SoCs with Pitaya-Link","text":""},{"location":"programming-nrf5x-socs-with-pitaya-link/#programming-nrf5x-socs-with-pitaya-link","title":"Programming nRF5x SoCs with Pitaya-Link","text":""},{"location":"programming-nrf5x-socs-with-pitaya-link/#introduction","title":"Introduction","text":"<p>Pitaya-Link is a low-cost debug probe based on the CMSIS-DAP (also known as DAPLink) protocol standard. It can be used to program and debug the application software running on Arm Cortex Microcontrollers.</p> <p>The design enables developers with Drag-And-Drop programming, Virtual COM Port, CMSIS-DAP compliant debug channel, and access to Arm Cortex Microcontrollers in the browser using WebUSB.</p> <p>The probe comes with indicator LEDs, a button to reset the target or trigger the firmware update, reversible USB-C connector and easy-to-use 7-pin 2.54mm Header.</p> <p></p>"},{"location":"programming-nrf5x-socs-with-pitaya-link/#what-youll-need","title":"What you'll need","text":"<ul> <li>1x Pitaya-Link Debug Probe</li> <li>A macOS/Linux/Windows PC</li> <li>An nRF52 target board(e.g. nRF52840 MDK USB Dongle)</li> </ul>"},{"location":"programming-nrf5x-socs-with-pitaya-link/#installing-pyocd","title":"Installing pyOCD","text":"<p>pyOCD is an open source Python package for programming and debugging Arm Cortex-M microcontrollers using multiple supported types of USB debug probes. It is fully cross-platform, with support for Linux, macOS, and Windows.</p> <p>The latest stable version of pyOCD may be installed via pip as follows:</p> <pre><code>python3 -mpip install -U pyocd\n</code></pre> <p>Alternatively, you can install the latest prerelease version from the HEAD of the <code>develop</code> branch, you can do the following:</p> <pre><code>$ python3 -mpip install --pre -U git+https://github.com/pyocd/pyOCD.git@develop\n</code></pre> <p>Verify if pyOCD works correctly in your terminal:</p> <pre><code>pyocd --version\n</code></pre>"},{"location":"programming-nrf5x-socs-with-pitaya-link/#connecting-the-target","title":"Connecting the target","text":"<p>Perform the following steps to connect your nRF5x target board:</p> <ol> <li>Connect the target board to Pitaya-Link using the provided 7-pin Cable.</li> <li>Connect Pitaya-Link to the PC using the provided USB-C Cable.</li> <li>A disk drive called PITAYA-LINK will be automatically detected by the computer.</li> </ol> <p></p>"},{"location":"programming-nrf5x-socs-with-pitaya-link/#programming","title":"Programming","text":"<p>Pitaya-Link allows programming of your target MCU in the following two very simple ways:</p> <ul> <li>Intuitive Drag-And-Drop programming</li> <li>Using the <code>pyocd</code> executable</li> </ul>"},{"location":"programming-nrf5x-socs-with-pitaya-link/#drag-and-drop-programming","title":"Drag-and-drop programming","text":"<p>Drag-And-Drop is an optional intuitive programming feature. It allows programming of your target MCU by dragging and dropping a file ( <code>.hex</code> -format) onto the PITAYA-LINK drive.</p> <p>There is no need to install application software. Anyone that can drag and drop a file to a USB memory stick can now program the target board.</p> <p></p>"},{"location":"programming-nrf5x-socs-with-pitaya-link/#using-the-pyocd-executable","title":"Using the pyocd executable","text":"<p>The <code>pyocd</code> command line tool gives you total control over your device with these subcommands:</p> <ul> <li><code>gdbserver</code>: GDB remote server allows you to debug using gdb via either the console or several GUI debugger options.</li> <li><code>load</code>: Program files of various formats into flash or RAM.</li> <li><code>erase</code>: Erase part or all of an MCU's flash memory.</li> <li><code>pack</code>: Manage CMSIS Device Family Packs that provide additional target device support.</li> <li><code>commander</code>: Interactive REPL control and inspection of the MCU.</li> <li><code>server</code>: Share a debug probe with a TCP/IP server.</li> <li><code>reset</code>: Hardware or software reset of a device.</li> <li><code>rtt</code>: Stream Segger RTT IO with any debug probe.</li> <li><code>list</code>: Show connected devices.</li> </ul> <p>You can get additional help by adding <code>--help</code> option.</p> <p>To load/erase the nRF52840-based target, open up a terminal and run:</p> Load <code>.hex</code>Load <code>.bin</code>Chip Erase <pre><code>pyocd load -t nrf52840 firmware.hex\n</code></pre> <pre><code>pyocd load -t nrf52840 --base-address 0x1000 firmware.bin\n</code></pre> <pre><code>pyocd erase -t nrf52840 --chip\n</code></pre>"},{"location":"programming-nrf5x-socs-with-pitaya-link/#explore-further","title":"Explore Further","text":"<p>Now that you are familiar with the Pitaya-Link, it's time to explore more tutorials available below:</p> <ul> <li>Using Pitaya-Link with DAP.js</li> <li>Using Pitaya-Link with Visual Studio Code</li> <li>Using Pitaya-Link with GNU MCU Eclipse</li> <li>Using Pitaya-Link with KEIL \u00b5Vision IDE</li> <li>Using Pitaya-Link with IAR Embedded Workbench</li> <li>Upgrading the DAPLink Firmware</li> <li>Building your own DAPLink Firmware</li> </ul>"},{"location":"archive/2025/","title":"2025","text":""},{"location":"archive/2024/","title":"2024","text":""},{"location":"archive/2023/","title":"2023","text":""},{"location":"archive/2020/","title":"2020","text":""},{"location":"archive/2019/","title":"2019","text":""},{"location":"category/learn/","title":"Learn","text":""},{"location":"category/news/","title":"News","text":""},{"location":"category/mechanical-keyboards/","title":"Mechanical Keyboards","text":""},{"location":"category/learn/page/2/","title":"Learn","text":""}]}